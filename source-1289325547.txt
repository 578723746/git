Fun brainstorm session about "Users' Git Helper", a potential new porcelain

In a not so serious Skype conversation, the issue of Git's usability came
up. Once again. It is a sad thing that still, the user interface design of
Git has nothing in common with the straight-forward, beautiful and simple
design of the data structures beneath.

It is still quite common for me to suggest using Subversion to other people
because it is easier to use.

So the idea was to have a new "porcelain" for Git, which would try much,
much harder to be intuitive than all the other porcelains which try to fix
the user interface warts of the Git command line interface.

In other words, the idea is that there is no way you can fix the command-line
interface, for a number of reasons, not the least of which is the inertia of
a precious few power-users, which according to <a href="http://developer.apple.com/library/mac/documentation/UserExperience/Conceptual/AppleHIGuidelines/XHIGIntro/XHIGIntro.html">Apple's Human Interface Guidelines</a> is not a good thing:
<a href="http://developer.apple.com/library/mac/documentation/UserExperience/Conceptual/AppleHIGuidelines/XHIGDesignProcess/XHIGDesignProcess.html#//apple_ref/doc/uid/TP40002718-TPXREF136">"If you try to design for the 20 percent of your target audience who are power users, your design may not be usable by the other 80 percent of users."</a>. Just as an example, what does splitting a mailbox into individual mails have to do with Version Control? Exactly.

Guiding principle would be the 80 percent solution, or analogously:

<ul>
<li> Optimize for the common case.
<li> Make the simple easy and the difficult possible.
<li> Before the green button, the Xerox machine was unusable.
</ul>

So many different ways to describe the same thing :-)

But enough of the philosophical talk. Let's look at some possible interface design. First things first, the name. Users' Git Helper:

<bash>
ugh
</bash>

The first thing you usually want to do<sup><a name="ref-1" /><a href="#foot-1">1</a></sup>: get the project from somewhere:

<bash>
ugh get URL
</bash>

The next thing is probably that you want to look at what you got.

<bash>
ugh show [ANYTHING, INCLUDING COMMIT NAMES]
</bash>

It would default at showing the current commit, with the branch name and then
the abbreviated commit name in parentheses.

In general, no command would show the usage when called without options. That
is what

<bash>
ugh help COMMAND
</bash>

is for. And this command would not call 'man' to do the job. It would do the
job.

<bash>
ugh commit
</bash>

would have no options, as it tries to discover what is there, and lets the user
choose between options, most sensible ones first.

To share your work with others,

<bash>
ugh publish [REMOTE]
</bash>

would do that. The default remote would be the one from which you branched off.

Oh, and of course, there <a href="http://developer.apple.com/library/mac/documentation/UserExperience/Conceptual/AppleHIGuidelines/XHIGHIDesign/XHIGHIDesign.html#//apple_ref/doc/uid/TP30000353-TPXREF107">must be an undo</a>:

<bash>
ugh undo
</bash>

The 'undo' command must be intelligent about what makes sense and what not.
For example, once published, the commit should not be undoable, except on
another branch. And undoing a "publish" should not be possible, except if
the respective remote is marked as "personal", and the user should be told
how to set this conveniently.

Inside a repository, "ugh get" would try to pull the tracked branch if it
fast-forwards (but it would not say the word "fast-forward"; I had to explain
the meaning of that term one hundred billion times; one hundred billion times
too many, if you ask me), but fetch in any case and error out with the message
that there are local commits in addition to remote ones, so a merge is
necessary:

<bash>
ugh merge [REMOTE [BRANCH]]
</bash>

Since people are familiar with other commands, "ugh <command> --help" would be
an alias to "ugh help <command>". But it would not be advertised in the
documentation, because documentation is where you learn how the program is
intended to be used.

No rebase.

What is a "rebase"? What would you have answered in 2004? Me, too, I would have
said "dunno, tell me!".

So it is all about branches.

<bash>
ugh branch
</bash>

<bash>
ugh branches
</bash>

shows the branches.

<bash>
ugh branch create BRANCH
</bash>

If you want to know what "rebase" means, this is how it would be spelt out:

<bash>
ugh branch move BRANCH
</bash>

Or something else, if you can come up with a more sensible name.

Now, how to handle "backward compatibility"?

No backwards compatibility. Not needed. Old farts like us can always use

<bash>
git make --me --sad
</bash>

or even

<bash>
git make ME^..sad
</bash>

By the way, even the usability of the string "ugh" is thought through: if you
use just one hand to type it very quickly, you end up with the correct finger
in the end.

<h4>Footnotes</h4>

<a name="foot-1" /><a href="#ref-1">1</a>: In the olden days, there were no
repositories to get from somewhere, so it is obvious why the initial user
interface design did not make that easy. Now, you might think that a "git clone"
is not too bad, but why all these differences between "clone", "fetch", "pull"?
Exactly, because the technical details -- the very same users could not care
less about -- are different.
