<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
<title>Dscho's blog</title>
<link>http://repo.or.cz/w/git/dscho.git?a=blob_plain;hb=blog;f=index.html</link>
<atom:link href="http://repo.or.cz/w/git/dscho.git?a=blob_plain;hb=blog;f=blog.rss" rel="self" type="application/rss+xml"/>
<description>A few stories told by Dscho</description>
<lastBuildDate>Sun, 08 Mar 2009 03:29:50 +0100</lastBuildDate>
<language>en-us</language>
<item>
<title>New Git for Windows version</title>
<link>http://repo.or.cz/w/git/dscho.git?a=blob_plain;hb=blog;f=index.html#1236479389</link>
<guid>http://repo.or.cz/w/git/dscho.git?a=blob_plain;hb=blog;f=index.html#1236479389</guid>
<pubDate>Sun, 08 Mar 2009 03:29:49 +0100</pubDate>
<description><![CDATA[New Git for Windows version
</p><p>
Phew.  That was quite a day, almost exclusively spent on finishing that
installer.  The worst part: updating GCC seemed not to be such a good idea
after all...
</p><p>
For Windows, we need to use the printf format <i>%I64u</i> (which is
non-standard, in the common way of Microsoft) if you want to print 64-bit
wide unsigned numbers.  The rest of the world accepts the standard <i>%llu</i>.
</p><p>
After upgrading to the new GCC, a lot of warnings appeared, complaining
about <i>%I64u</i>.  The warnings went away when I replaced the format with
<i>%llu</i>.
</p><p>
Being the naive I am, I mistook that for a sign that we could finally go
more standards-compliant.
</p><p>
However, it only means that we have to live with the warnings for now, as
the C runtime provided on Windows still strongly disagrees with standards
(and it has to continue to do so, lest it break existing programs).
</p><p>
Sigh.
</p><p>
At least I have the feeling that I caught the most important bugs before
releasing.]]></description>
</item>
<item>
<title>Code reviews</title>
<link>http://repo.or.cz/w/git/dscho.git?a=blob_plain;hb=blog;f=index.html#1235092615</link>
<guid>http://repo.or.cz/w/git/dscho.git?a=blob_plain;hb=blog;f=index.html#1235092615</guid>
<pubDate>Fri, 20 Feb 2009 02:16:55 +0100</pubDate>
<description><![CDATA[Code reviews
</p><p>
It has been said that reviewing patches is a most thankless job.  As I really
like the elegance of Git's source code, and care a lot about it, I did not
think that it was thankless, just a little bit tedious (especially when the
patch authors mistake criticism for personal attacks).
</p><p>
Usually, I am pretty good at ignoring insults as responses to my comments;
after all, I have a lot more enjoyable things to do than to spend time talking
to a guy who shows how wise he is when he thinks that I criticize him
<u>personally</u> when I just try to enhance his work, by offering a little bit of
my knowledge.
</p><p>
However, in the last days, three people really seemed to want to insult me,
to make me go away, to stop the fun I have with Git.
</p><p>
And they almost succeeded.
</p><p>
So I guess it is time to reassess my priorities, and maybe stop reviewing
Git patches altogether.]]></description>
</item>
<item>
<title>Interactive rebase just learnt a new command: topic</title>
<link>http://repo.or.cz/w/git/dscho.git?a=blob_plain;hb=blog;f=index.html#1234409395</link>
<guid>http://repo.or.cz/w/git/dscho.git?a=blob_plain;hb=blog;f=index.html#1234409395</guid>
<pubDate>Thu, 12 Feb 2009 04:29:55 +0100</pubDate>
<description><![CDATA[Interactive <i>rebase</i> just learnt a new command: <i>topic</i>
</p><p>
Today I am pretty pleased with myself.  Two projects at my day job got a real
boost, and I implemented a shortcut that avoids the ugly 'bookmark' statement
in rebase scripts most of the time.
</p><p>
A typical rebase script, generated by <i>git rebase -i -p $COMMIT</i> will look
something like this:
</p><p>
<table
				border=1 bgcolor=white>
			<tr><td bgcolor=lightblue colspan=3>
				<pre>                                                                                </pre>
			</td></tr>
			<tr><td>
				<table cellspacing=5 border=0
					 style="color:black;">
				<tr><td>
					<pre>
pick 1234567 My first commit
topic begin super-cool-feature
pick 2345678 The super cool feature
pick 3456789 Documentation for the super cool feature
topic end super-cool-feature
</pre>
				</td></tr>
				</table>
			</td></tr>
			</table>
</p><p>
The result will be a merge commit at the HEAD whose first parent is
"My first commit", whose second parent is "Documentation for the super
cool feature" and whose commit message is "Merge branch 'super-cool-feature'".
</p><p>
Side note: internally, <i>topic begin $NAME [at $COMMIT]</i> will be handled as if
you wrote <i>bookmark merge-parent-of-$NAME; goto $COMMIT</i>, and
<i>topic end $NAME [$MESSAGE]</i> will be handled as if you wrote
<i>bookmark $NAME; goto merge-parent-of-$NAME; merge parents $NAME [original $MARK Merge branch '$NAME']</i>.
</p><p>
Of course, being more concise, the 'topic' statement is not only nicer to the
eye, but also less error-prone.
</p><p>
And hopefully many people will agree with me that this rebase script is pretty
intuitive.]]></description>
</item>
<item>
<title>Thunderbird, oh Thunderbird, you always make my small brain hurt</title>
<link>http://repo.or.cz/w/git/dscho.git?a=blob_plain;hb=blog;f=index.html#1234320806</link>
<guid>http://repo.or.cz/w/git/dscho.git?a=blob_plain;hb=blog;f=index.html#1234320806</guid>
<pubDate>Wed, 11 Feb 2009 03:53:26 +0100</pubDate>
<description><![CDATA[Thunderbird, oh Thunderbird, you always make my small brain hurt
</p><p>
There was a lengthy discussion on the Git mailing list about using Thunderbird,
a not quite unpopular mailing program, to send inline patches.
</p><p>
It is really kind of sad that the Thunderbird developers do not see how
stubbornly they offend quite a number of people and scare them away from their
program.  After all, you should try to be liberal in what you accept and strict
in what you emit.  No, that does not mean that you should force others to
switch their mailers because you strictly adher to your philosophy in what you
emit, ignoring the rest of the world.
</p><p>
In any case, I am not affected (as long as I do not get mails from a poor soul
stuck with Thunderbird).
</p><p>
But I was a bit mean to that Thunderbird guy I dragged into the discussion, and
he seems really offended.
</p><p>
So I thought I'd give him a real reason to feel offended: I'll just do his work: 
</p><p>
http://<a href=http://repo.or.cz>repo.or.cz</a>/w/UnFlowedThunderbird.git
</p><p>
It took my free time of two days, being not a Thunderbird developer myself.
Hopefully it works, and hopefully some people will feel really ashamed now.]]></description>
</item>
<item>
<title>format-patch --thread and Alpine</title>
<link>http://repo.or.cz/w/git/dscho.git?a=blob_plain;hb=blog;f=index.html#1234141489</link>
<guid>http://repo.or.cz/w/git/dscho.git?a=blob_plain;hb=blog;f=index.html#1234141489</guid>
<pubDate>Mon, 09 Feb 2009 02:04:49 +0100</pubDate>
<description><![CDATA[<i>format-patch --thread</i> and Alpine
</p><p>
I started recently to pipe the output of
<i>git format-patch --cover-letter --stdout ...</i> directly into the
<i>postponed-msgs</i> folder Alpine uses, instead of pasting files into the
mailer.
</p><p>
The idea is to pretend that I continue a postponed mail, but in reality I
never wrote it, <i>format-patch</i> did.
</p><p>
However, I had problems with the <i>--thread</i> option that is implied by
<i>--cover-letter</i>.  Alpine always generated new message IDs without adjusting
the <i>In-reply-to:</i> and <i>References:</i> headers of the other mails.
</p><p>
Now I found out that the reason is that the <i>Fcc:</i> headers were missing in
the mails, and Alpine generated them, making up new message IDs in the process.
</p><p>
Therefore I have an alias now which sets not only the <i>Fcc:</i> header, but also
the <i>To:</i> headers by rewriting the stream using <i>sed</i>.  This is slightly
ugly, but so is the handling of headers in <i>format-patch</i>: if you thought
you could specify arbitrary headers using the command line, you are mistaken:
you can do that only by editing the config.
</p><p>
While at it, I also noticed a bug whereby <i>--thread --in-reply-to=...</i> simply
forgets the <i>--thread</i>.  Maybe this week I will find time to address this bug.]]></description>
</item>
<item>
<title>rebase updates</title>
<link>http://repo.or.cz/w/git/dscho.git?a=blob_plain;hb=blog;f=index.html#1234140696</link>
<guid>http://repo.or.cz/w/git/dscho.git?a=blob_plain;hb=blog;f=index.html#1234140696</guid>
<pubDate>Mon, 09 Feb 2009 01:51:36 +0100</pubDate>
<description><![CDATA[<i>rebase</i> updates
</p><p>
Phew.  The last few days, I was mainly chasing bugs I introduced due to being
too tired to work on the merge-preserving, interactive <i>rebase</i>.
</p><p>
But finally I have something I can start working with.  After my failed
experiment to use git-blame to split topic branches, I will sort the commits
in my <i>my-next</i> branch into topic branches manually.
</p><p>
Then I will add an option to <i>rebase -i -p</i> to rewrite refs which point to
rewritten commits, so that I can have branches <i>rebase-i-p</i>, <i>add-e</i>, etc
and all of them are automatically updated when I <i>rebase -i -p</i> the <i>my-next</i>
branch.
</p><p>
In the process, not only have I learnt the value of the <i>bookmark</i> command,
but made quite a few-much needed cleanups (which make
<i>git-rebase--interactive.sh</i> longer, but much more understandable).
</p><p>
Hopefully Stephan will pick the changes in the "rebase protocol" up, and then
we can have a sequencer with which I can start to make a graphical interactive
rebase using git-gui.  Or gitk.
</p><p>
Maybe.]]></description>
</item>
<item>
<title>The infamous mark command in the rebase command</title>
<link>http://repo.or.cz/w/git/dscho.git?a=blob_plain;hb=blog;f=index.html#1234040744</link>
<guid>http://repo.or.cz/w/git/dscho.git?a=blob_plain;hb=blog;f=index.html#1234040744</guid>
<pubDate>Sat, 07 Feb 2009 22:05:44 +0100</pubDate>
<description><![CDATA[The infamous <i>mark</i> command in the <i>rebase</i> command
</p><p>
I realized today how easy it is to lose commits with the "merge preserving"
mode of the interactive rebase.  In my case, it was when I tried to move a
bunch of commits from the tip of my branch into a topic branch.
</p><p>
But after moving the commits, I forgot to update the parent of the merge
commit.  Possibly a mark command could have helped.  The very same command
I called a nightmare for usability.
</p><p>
So I was wrong.  Big news.  &#x263a;
</p><p>
However, I think that the syntax "mark :1" is something best left for
machine consumption, not for human beings.
</p><p>
But I have an idea: we could use some garbled commit subject, or in case of
merge parents, the merge subject as some human readable title of the mark.
</p><p>
The rebase script would then look something like this:
</p><p>
<table
				border=1 bgcolor=white>
			<tr><td bgcolor=lightblue colspan=3>
				<pre>                                                                                </pre>
			</td></tr>
			<tr><td>
				<table cellspacing=5 border=0
					 style="color:black;">
				<tr><td>
					<pre>
pick abcdefg Some ultra cool commit
bookmark ultra-cool
goto upstream
pick hijklmn Some other cool commit
merge parent ultra-cool Merge 'ultra-cool' into master
</pre>
				</td></tr>
				</table>
			</td></tr>
			</table>
</p><p>
The good news is: I added code that refuses to finish a rebase when there
are commits that were rewritten, but not part of the new HEAD's ancestry.]]></description>
</item>
<item>
<title>New valgrind series</title>
<link>http://repo.or.cz/w/git/dscho.git?a=blob_plain;hb=blog;f=index.html#1233707628</link>
<guid>http://repo.or.cz/w/git/dscho.git?a=blob_plain;hb=blog;f=index.html#1233707628</guid>
<pubDate>Wed, 04 Feb 2009 01:33:48 +0100</pubDate>
<description><![CDATA[New valgrind series
</p><p>
I spent quite some time cleaning up that patch series, and feel pretty
exhausted.
</p><p>
Granted, the new <i>git rebase -i -p</i> does its job without complaint so far
(so much so that I think I'll release a version of my <i>rebase</i> series
soonish), but it <u>is</u> a hassle when you have patches that you have a hard
time to decide upon the order/commit boundaries.
</p><p>
For example, I could imagine that the patch making the location of the
templates independent of the location of the Git binaries should come
<u>before</u> my patch series, and the valgrind specific part should then
be squashed into the first valgrind commit.
</p><p>
Also, it uses two features of valgrind 3.4.0:
</p><p>
<ul>
<li><i>...</i> in the suppression file, and
<li><i>--track-origins=yes</i>
</ul>
</p><p>
The latter is actually the reason I am pretty willing to keep the
requirement of that valgrind version, as it is really, really useful.
</p><p>
I guess we will see what happens to it.]]></description>
</item>
<item>
<title>Problems with split-topic-branches.sh</title>
<link>http://repo.or.cz/w/git/dscho.git?a=blob_plain;hb=blog;f=index.html#1233706294</link>
<guid>http://repo.or.cz/w/git/dscho.git?a=blob_plain;hb=blog;f=index.html#1233706294</guid>
<pubDate>Wed, 04 Feb 2009 01:11:34 +0100</pubDate>
<description><![CDATA[Problems with split-topic-branches.sh
</p><p>
So my little script that should help me to split my topic branches does
not work properly.
</p><p>
First some background: the idea was to let <i>git blame</i> do the hard work
to find overlapping changes, i.e. changes that would conflict when
changing the order (or skipping the first change, on which the next builds).
</p><p>
The first problem with that approach: when lines are <u>removed</u> by one
commit, and the next commit touches the same location, <i>git blame</i> does
not find that the first commit is required by the second.
</p><p>
Therefore I introduced a really slow reverse thing which tries to find
those commits whose removals survived until the parent of a particular
commit, but not further.
</p><p>
However, it does not work properly.  Basically, only context sizes that
span the whole files lead to conflict-free topic branches so far.
</p><p>
As a consequence, I think I'll add an option --sprout to the revision
walker which will fake octopus merges (or a series of two-parent merges)
whenever it finds a perl of non-merge commits that are theoretically
independent, i.e. whose patches apply cleanly.]]></description>
</item>
<item>
<title>More valgrind fun</title>
<link>http://repo.or.cz/w/git/dscho.git?a=blob_plain;hb=blog;f=index.html#1233277286</link>
<guid>http://repo.or.cz/w/git/dscho.git?a=blob_plain;hb=blog;f=index.html#1233277286</guid>
<pubDate>Fri, 30 Jan 2009 02:01:26 +0100</pubDate>
<description><![CDATA[More valgrind fun
</p><p>
So I spent quite a number of hours on that funny zlib/valgrind issue.  The
thing is, zlib people claim that even if their code accesses uninitialized
memory, it does not produce erroneous data (by cutting out the results of the
uninitialized data, which is cheaper than checking for the end of the buffer
in an unaligned manner), so zlib will always be special for valgrind.
</p><p>
However, the bug I was chasing is funny, and different from said issue.  zlib
deflates an input buffer to an output buffer that is exactly 58 bytes long.
But valgrind claims that the 52nd of those bytes is uninitialized, and <u>only</u>
that one.
</p><p>
But it is not.  It must be 0x2c, otherwise zlib refuses to inflate the
buffer.
</p><p>
Now, I went into a debugging frenzy, and finally found out that zlib just
passes fine (with the default suppressions because of the "cute" way it
uses uninitialized memory), <u>except</u> when it is compiled with UNALIGNED_OK
defined.
</p><p>
Which Ubuntu does, of course.  Ubuntu, the biggest forker of all.
</p><p>
The bad part is that it sounds like a bug in valgrind, and I <u>could</u> imagine
that it is an issue of an optimized memcpy() that copies int by int, and
that valgrind misses out on the fact that a part of that int is actually
<u>not</u> uninitialized.
</p><p>
But my debugging session's results disagree with that.
</p><p>
With the help of Julian Seward, the original author of valgrind, I instrumented
zlib's source code so that valgrind checks earlier if the byte is initialized
or not, to find out where the reason of the issue lies.
</p><p>
The sad part is that when I added the instrumentation to both the <u>end</u> of
the while() loop in compress_block() in zlib's trees.c, and just <u>after</u> the
while() loop (whose condition is a plain <i>variable < variable</i> comparison,
nothing fancy, certainly not changing any memory), only the <u>latter</u> catches
a valgrind error.
</p><p>
And that is truly strange.]]></description>
</item>
</channel>
</rss>
